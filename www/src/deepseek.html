<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>个人博客</title>

    <!-- Viewport & color scheme 视口与颜色方案 -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <meta name="color-scheme" content="light dark" />
    <meta name="theme-color" content="#ffffff" />
    <meta
      name="theme-color"
      media="(prefers-color-scheme: dark)"
      content="#121212"
    />

    <!-- Stylesheets 样式表 -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css"
    />
    <link rel="stylesheet" href="../statics/css/deepseek.css" />
    <style>
      .context-reminder.subtle {
        font-size: 0.8em;
        opacity: 0.6;
        max-width: none;
        margin-top: 6px;
        text-align: right;
        border: none;
        background: transparent;
        color: inherit;
      }
      @media (prefers-color-scheme: dark) {
        .context-reminder.subtle {
          color: #aaa;
        }
      }
      
      /* 引用样式 */
      .citations {
        margin-top: 16px;
        padding: 12px;
        background: #f8f9fa;
        border-left: 4px solid #007bff;
        border-radius: 4px;
        font-size: 0.9em;
      }
      
      .citations h4 {
        margin: 0 0 8px 0;
        color: #007bff;
        font-size: 0.95em;
      }
      
      .citations ol {
        margin: 0;
        padding-left: 20px;
      }
      
      .citations li {
        margin-bottom: 6px;
        line-height: 1.4;
      }
      
      .citations a {
        color: #007bff;
        text-decoration: none;
        cursor: pointer;
        word-break: break-all;
      }
      
      .citations a:hover {
        text-decoration: underline;
        color: #0056b3;
      }
      
      .citations a:active {
        color: #004085;
      }
      
      /* 移动端优化 */
      @media (max-width: 768px) {
        .citations a {
          display: inline-block;
          padding: 2px 4px;
          margin: 1px 0;
          border-radius: 3px;
          background-color: rgba(0, 123, 255, 0.1);
          transition: background-color 0.2s;
        }
        
        .citations a:hover {
          background-color: rgba(0, 123, 255, 0.2);
        }
        
        .citations a:active {
          background-color: rgba(0, 123, 255, 0.3);
        }
      }
      
      .disclaimer {
        margin-top: 12px;
        padding: 10px;
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        font-size: 0.9em;
        color: #856404;
      }
      
      @media (prefers-color-scheme: dark) {
        .citations {
          background: #2d3748;
          border-left-color: #63b3ed;
        }
        
        .citations h4 {
          color: #63b3ed;
        }
        
        .citations a {
          color: #63b3ed;
          cursor: pointer;
        }
        
        .citations a:hover {
          color: #4299e1;
          text-decoration: underline;
        }
        
        .citations a:active {
          color: #3182ce;
        }
        
        .disclaimer {
          background: #744210;
          border-color: #d69e2e;
          color: #fbd38d;
        }
      }
      
      /* 按钮组样式 */
      .button-group {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      
      #clearBtn {
        background: #6c757d;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s;
      }
      
      #clearBtn:hover {
        background: #5a6268;
      }
      
      #sendBtn {
        background: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }
      
      #sendBtn:hover {
        background: #0056b3;
      }
      
      #sendBtn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }
      
      @media (prefers-color-scheme: dark) {
        #clearBtn {
          background: #495057;
        }
        
        #clearBtn:hover {
          background: #343a40;
        }
        
        #sendBtn {
          background: #0d6efd;
        }
        
        #sendBtn:hover {
          background: #0b5ed7;
        }
      }
      
    </style>

    <!-- Third-party libs 外部库（defer 避免阻塞渲染） -->
    <script
      src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"
      defer
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"
      defer
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js" defer></script>
    <script
      src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"
      defer
    ></script>
  </head>

  <body>
    <!-- Chat container 聊天容器 -->
    <div class="chat-container">
      <!-- Message list 消息列表：使用可访问性语义 -->
      <div
        class="message-list"
        id="messageList"
        role="log"
        aria-live="polite"
        aria-relevant="additions"
      ></div>

      <!-- Input area 输入区 -->
      <div class="input-container">
        <textarea
          id="userInput"
          placeholder="请输入您的健康问题..."
          autocomplete="off"
          aria-label="输入您的健康问题"
          onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
          rows="1"
        ></textarea>
        <div class="button-group">
          <button
            type="button"
            id="clearBtn"
            onclick="clearSession()"
            aria-label="清除会话"
            title="清除对话历史"
          >
            清除
          </button>
          <button
            type="button"
            id="sendBtn"
            onclick="sendMessage()"
            aria-label="发送消息"
          >
            发送
          </button>
        </div>
    

    <script>
      // Wait for deferred libs 等第三方库加载完成
      window.addEventListener("DOMContentLoaded", () => {
        // marked config: soft line breaks & safer defaults
        if (window.marked) {
          marked.setOptions({ breaks: true, mangle: false, headerIds: false });
        }
        
        // 恢复会话ID
        restoreSessionId();
        
        generateGreeting();
        
        // 自动调整textarea高度
        const textarea = document.getElementById('userInput');
        if (textarea) {
          textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
          });
        }

        // 监听所有链接点击事件，确保在默认浏览器中打开
        document.addEventListener('click', function(e) {
          if (e.target.tagName === 'A' && e.target.href) {
            e.preventDefault();
            // 在默认浏览器中打开链接
            if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Browser) {
              // 如果是在Capacitor环境中，使用Browser插件
              window.Capacitor.Plugins.Browser.open({ url: e.target.href });
            } else {
              // 在普通浏览器环境中，使用window.open
              window.open(e.target.href, '_blank', 'noopener,noreferrer');
            }
          }
        });
      });

      /**
       * Sanitize + render Markdown 安全渲染 Markdown
       * - 使用 DOMPurify 进行 XSS 过滤
       */
      function renderMarkdownSafe(mdText) {
        const html = window.marked ? marked.parse(mdText || "") : mdText || "";
        let sanitizedHtml = window.DOMPurify
          ? DOMPurify.sanitize(html, { 
              USE_PROFILES: { html: true },
              ADD_ATTR: ['target', 'rel'] // 允许target和rel属性
            })
          : html;
        
        // 确保所有外部链接都在新窗口打开
        sanitizedHtml = sanitizedHtml.replace(/<a\s+([^>]*?)href="([^"]*?)"([^>]*?)>/gi, (match, before, href, after) => {
          // 如果是外部链接，确保有target="_blank"
          if (href.startsWith('http') && !match.includes('target=')) {
            return `<a ${before}href="${href}"${after} target="_blank" rel="noopener noreferrer">`;
          }
          return match;
        });
        
        return sanitizedHtml;
      }

      // 会话管理
      let currentSessionId = null;
      
      // 生成会话ID
      function generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }
      
      // 获取或创建会话ID
      function getSessionId() {
        if (!currentSessionId) {
          currentSessionId = generateSessionId();
          // 保存到localStorage
          localStorage.setItem('qwen_session_id', currentSessionId);
        }
        return currentSessionId;
      }
      
      // 从localStorage恢复会话ID
      function restoreSessionId() {
        const saved = localStorage.getItem('qwen_session_id');
        if (saved) {
          currentSessionId = saved;
        }
      }
      
      // 清除会话
      async function clearSession() {
        try {
          const apiBase = window.__API_BASE__ || (window.parent && window.parent.__API_BASE__) || 'https://app.zdelf.cn';
          const baseUrl = apiBase.endsWith('/') ? apiBase.slice(0, -1) : apiBase;
          
          const response = await fetch(`${baseUrl}/deepseek/clear_session`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_id: currentSessionId })
          });
          
          if (response.ok) {
            // 清除本地会话ID
            currentSessionId = null;
            localStorage.removeItem('qwen_session_id');
            
            // 清空消息列表
            const msgList = document.getElementById("messageList");
            msgList.innerHTML = '';
            
            // 重新生成问候
            generateGreeting();
            
            console.log('会话已清除');
          }
        } catch (error) {
          console.error('清除会话失败:', error);
        }
      }

      // 初始问候
      function generateGreeting() {
        const now = new Date();
        const hour = now.getHours();
        console.log('当前时间:', now.toLocaleString(), '小时:', hour);
        
        let greet = "您好！我是您的健康助手，有什么健康问题尽管问我哦~";
        if (hour >= 5 && hour < 11) {
          greet = "早上好 ☀️，祝你有愉快的一天！有什么健康问题可以问我";
        } else if (hour >= 11 && hour < 14) {
          greet = "中午好 🍵，注意补水，有什么健康问题想问的？";
        } else if (hour >= 14 && hour < 18) {
          greet = "下午好 🌿，上午过得如何呢？有什么健康问题可以咨询我";
        } else if (hour >= 18 && hour < 22) {
          greet = "晚上好 🌙，今天感觉怎么样？可以准备休息喽～有什么健康问题可以问我";
        } else {
          greet = "夜深了 🌃，美好的一天过去了，早点休息哦～有什么健康问题可以问我";
        }
        addMessage(greet, "bot");
      }

      // 打字中占位气泡 typing bubble
      function addTypingBubble() {
        const msgList = document.getElementById("messageList");
        const wrap = document.createElement("div");
        wrap.className = "message bot typing";
        wrap.setAttribute("aria-label", "正在回复");
        wrap.innerHTML =
          '<span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
        msgList.appendChild(wrap);
        msgList.scrollTop = msgList.scrollHeight;
        return wrap;
      }

      async function sendMessage() {
        const inputEl = document.getElementById("userInput");
        const btn = document.getElementById("sendBtn");
        const message = inputEl.value.trim();
        if (!message) return;

        inputEl.disabled = true;
        btn.disabled = true;

        addMessage(message, "user");
        inputEl.value = "";

        const thinkingMsg = addTypingBubble();

        try {
          // 获取API基础路径
          const apiBase = window.__API_BASE__ || (window.parent && window.parent.__API_BASE__) || 'https://app.zdelf.cn';
          const baseUrl = apiBase.endsWith('/') ? apiBase.slice(0, -1) : apiBase;
          
          // 获取会话ID
          const sessionId = getSessionId();
          
          // 首先尝试使用流式接口
          const response = await fetch(
            `${baseUrl}/deepseek/chat_stream`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ 
                message: message,
                session_id: sessionId
              }),
            }
          );

          if (response.ok) {
            // 移除打字中状态
            thinkingMsg.classList.remove("typing");

            // 处理流式响应
            await handleStreamResponse(thinkingMsg, response);

            if (window.Prism) Prism.highlightAll();
          } else {
            // 流式接口失败，回退到普通接口 + 打字机效果
            await fallbackToLegacy(thinkingMsg, message, sessionId);
          }
        } catch (error) {
          // 网络错误，也回退到普通接口
          await fallbackToLegacy(thinkingMsg, message, getSessionId());
        } finally {
          inputEl.disabled = false;
          btn.disabled = false;
          inputEl.focus();
        }
      }

      // 回退到普通接口 + 打字机效果
      async function fallbackToLegacy(thinkingMsg, message, sessionId) {
        try {
          // 获取API基础路径
          const apiBase = window.__API_BASE__ || (window.parent && window.parent.__API_BASE__) || 'https://app.zdelf.cn';
          const baseUrl = apiBase.endsWith('/') ? apiBase.slice(0, -1) : apiBase;
          
          const response = await fetch(
            `${baseUrl}/deepseek/chat`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ 
                message: message,
                session_id: sessionId
              }),
            }
          );

          const data = await response.json().catch(() => ({}));
          if (response.ok && data && typeof data.reply === "string") {
            thinkingMsg.classList.remove("typing");

            // 启动打字机效果
            await typewriterEffect(thinkingMsg, data.reply);

            if (window.Prism) Prism.highlightAll();
          } else {
            thinkingMsg.classList.remove("typing");
            thinkingMsg.textContent =
              "❌ 出错了：" +
              (data.error || response.status + " " + response.statusText);
          }
        } catch (error) {
          thinkingMsg.classList.remove("typing");
          thinkingMsg.textContent =
            "⚠️ 无法连接服务器：" +
            (error && error.message ? error.message : "Network error");
        }
      }

      // 处理流式响应
      async function handleStreamResponse(element, response) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let fullText = "";

        // 创建内容容器
        const content = document.createElement("div");
        content.className = "msg-content";
        element.appendChild(content);

        try {
          while (true) {
            const { done, value } = await reader.read();

            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop(); // 保留不完整的行

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const dataStr = line.slice(6);
                if (dataStr === "[DONE]") {
                  // 最终渲染完整的markdown并高亮代码
                  content.innerHTML = renderMarkdownSafe(fullText);
                  if (window.Prism) Prism.highlightAll();
                  return;
                }

                try {
                  const data = JSON.parse(dataStr);
                  if (data.type === "content" && data.content) {
                    fullText += data.content;
                    // 实时显示当前内容
                    content.innerHTML = renderMarkdownSafe(fullText);

                    // 滚动到底部
                    const msgList = document.getElementById("messageList");
                    msgList.scrollTop = msgList.scrollHeight;
                  } else if (data.type === "citations" && data.content) {
                    // 处理引用信息
                    fullText += data.content;
                    content.innerHTML = renderMarkdownSafe(fullText);
                    
                    // 滚动到底部
                    const msgList = document.getElementById("messageList");
                    msgList.scrollTop = msgList.scrollHeight;
                  } else if (data.type === "disclaimer" && data.content) {
                    // 处理免责声明
                    fullText += data.content;
                    content.innerHTML = renderMarkdownSafe(fullText);
                    
                    // 滚动到底部
                    const msgList = document.getElementById("messageList");
                    msgList.scrollTop = msgList.scrollHeight;
                  } else if (data.type === "error") {
                    content.innerHTML = "❌ 错误：" + data.error;
                    return;
                  }
                } catch (e) {
                  console.warn("解析流数据失败:", e);
                }
              }
            }
          }
        } catch (error) {
          console.error("流式响应处理错误:", error);
          content.innerHTML = "⚠️ 响应处理错误：" + error.message;
        } finally {
          reader.releaseLock();
        }
      }

      // 打字机效果函数
      async function typewriterEffect(element, text) {
        // 清空元素内容
        element.innerHTML = "";

        // 创建内容容器
        const content = document.createElement("div");
        content.className = "msg-content";
        element.appendChild(content);

        // 逐字显示文本
        for (let i = 0; i < text.length; i++) {
          const char = text[i];

          // 处理换行符
          if (char === "\n") {
            content.innerHTML += "<br>";
          } else {
            // 渲染当前文本（包含已显示的字符）
            const currentText = text.substring(0, i + 1);
            content.innerHTML = renderMarkdownSafe(currentText);
          }

          // 滚动到底部
          const msgList = document.getElementById("messageList");
          msgList.scrollTop = msgList.scrollHeight;

          // 动态调整打字速度：标点符号稍慢，普通字符稍快
          let currentSpeed = 30; // 默认30ms
          if (
            ["。", "！", "？", "；", "：", ".", "!", "?", ";", ":"].includes(
              char
            )
          ) {
            currentSpeed = 60; // 标点符号停顿时间更长
          } else if (["，", "、", ",", " "].includes(char)) {
            currentSpeed = 45; // 逗号和空格稍慢
          }

          // 等待一段时间再显示下一个字符
          await new Promise((resolve) => setTimeout(resolve, currentSpeed));
        }

        // 最终渲染完整的markdown并高亮代码
        content.innerHTML = renderMarkdownSafe(text);
        if (window.Prism) Prism.highlightAll();
      }

      // 停止打字功能
      function stopTyping() {
        if (currentTypingTask !== null) {
          currentTypingTask = "stop";
          const stopBtn = document.getElementById("stopTyping");
          stopBtn.style.display = "none";
        }
      }

      // 添加消息到列表
      function addMessage(text, sender, returnElement = false) {
        const msgList = document.getElementById("messageList");
        const msgDiv = document.createElement("div");
        msgDiv.className = "message " + sender;

        // avatar（仅机器人显示头像，用户不显示）
        let avatar = null;
        if (sender === 'bot') {
          avatar = document.createElement('img');
          avatar.className = 'avatar';
          avatar.src = '../images/doctor.png';
          avatar.alt = 'Doctor';
        }

        const content = document.createElement("div");
        content.className = "msg-content";

        if (sender === "bot") {
          content.innerHTML = renderMarkdownSafe(text);
        } else {
          // User text as plain text to avoid injection 用户消息按纯文本插入
          content.textContent = text;
        }

        // iMessage-like layout: avatar + bubble（仅bot带头像）
        if (avatar) msgDiv.appendChild(avatar);
        msgDiv.appendChild(content);
        msgList.appendChild(msgDiv);
        msgList.scrollTop = msgList.scrollHeight;
        if (window.Prism) Prism.highlightAll();
        return returnElement ? msgDiv : undefined;
      }
    </script>
  </body>
</html>
